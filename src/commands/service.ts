/**
 * Service installer — configures the proxy to start automatically
 * when the computer boots.
 *
 * Supports:
 * - **macOS**: launchd (~/Library/LaunchAgents/)
 * - **Linux**: systemd user service (~/.config/systemd/user/)
 * - **Windows**: VBS wrapper in Startup folder
 *
 * The installer persists the configuration (API key, port, host, model)
 * in a `.env.service` file next to the project, and the service
 * definition references it.
 */

import { existsSync, mkdirSync, writeFileSync, unlinkSync, readFileSync } from "fs";
import { join, resolve } from "path";
import { homedir, platform } from "os";
import { execSync } from "child_process";

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const SERVICE_NAME = "gemini-claude-code";
const SERVICE_LABEL = "com.gemini-claude-code.proxy";
const SERVICE_DESCRIPTION = "Gemini ↔ Anthropic API Proxy for Claude Code";

// ---------------------------------------------------------------------------
// ANSI colour helpers
// ---------------------------------------------------------------------------

const C = {
  reset: "\x1b[0m",
  bold: "\x1b[1m",
  dim: "\x1b[2m",
  cyan: "\x1b[36m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  red: "\x1b[31m",
} as const;

// ---------------------------------------------------------------------------
// Service configuration
// ---------------------------------------------------------------------------

export interface ServiceConfig {
  apiKey: string;
  port: number;
  host: string;
  model?: string;
  verbose: boolean;
  projectDir: string;
}

// ---------------------------------------------------------------------------
// ServiceInstaller
// ---------------------------------------------------------------------------

/**
 * Cross-platform service installer for the proxy server.
 *
 * Detects the operating system and uses the appropriate mechanism
 * to register the proxy as an auto-start service.
 */
export class ServiceInstaller {
  private readonly config: ServiceConfig;
  private readonly os: NodeJS.Platform;

  constructor(config: ServiceConfig) {
    this.config = config;
    this.os = platform();
  }

  // -------------------------------------------------------------------------
  // Public API
  // -------------------------------------------------------------------------

  /**
   * Installs the service for auto-start on boot/login.
   */
  install(): void {
    // Save config to .env.service
    this.saveServiceConfig();

    switch (this.os) {
      case "darwin":
        this.installMacOS();
        break;
      case "linux":
        this.installLinux();
        break;
      case "win32":
        this.installWindows();
        break;
      default:
        console.error(
          `${C.red}${C.bold}Error:${C.reset} Unsupported OS: ${this.os}`
        );
        process.exit(1);
    }
  }

  /**
   * Uninstalls the auto-start service.
   */
  uninstall(): void {
    switch (this.os) {
      case "darwin":
        this.uninstallMacOS();
        break;
      case "linux":
        this.uninstallLinux();
        break;
      case "win32":
        this.uninstallWindows();
        break;
      default:
        console.error(
          `${C.red}${C.bold}Error:${C.reset} Unsupported OS: ${this.os}`
        );
        process.exit(1);
    }

    // Remove .env.service
    const envPath = join(this.config.projectDir, ".env.service");
    if (existsSync(envPath)) {
      unlinkSync(envPath);
    }
  }

  /**
   * Shows the current service status.
   */
  status(): void {
    switch (this.os) {
      case "darwin":
        this.statusMacOS();
        break;
      case "linux":
        this.statusLinux();
        break;
      case "win32":
        this.statusWindows();
        break;
      default:
        console.error(
          `${C.red}${C.bold}Error:${C.reset} Unsupported OS: ${this.os}`
        );
    }
  }

  // -------------------------------------------------------------------------
  // Config persistence
  // -------------------------------------------------------------------------

  /**
   * Saves the service configuration to `.env.service` in the project directory.
   */
  private saveServiceConfig(): void {
    const envPath = join(this.config.projectDir, ".env.service");
    const content = [
      `# Generated by gemini-claude-code service installer`,
      `# ${new Date().toISOString()}`,
      `GEMINI_API_KEY=${this.config.apiKey}`,
      `PORT=${this.config.port}`,
      `HOST=${this.config.host}`,
      this.config.model ? `MODEL=${this.config.model}` : "",
      this.config.verbose ? `VERBOSE=true` : "",
    ]
      .filter(Boolean)
      .join("\n");

    writeFileSync(envPath, content + "\n", "utf-8");
    console.log(`  ${C.dim}Config saved to${C.reset} ${envPath}`);
  }

  /**
   * Loads saved config from .env.service to accurately report status
   */
  private getSavedConfig(): Partial<ServiceConfig> {
    const envPath = join(this.config.projectDir, ".env.service");
    if (!existsSync(envPath)) return {};
    try {
      const content = readFileSync(envPath, "utf-8");
      const config: Partial<ServiceConfig> = {};

      const portMatch = content.match(/^PORT=(\d+)$/m);
      if (portMatch) config.port = parseInt(portMatch[1], 10);

      const hostMatch = content.match(/^HOST=([^\n]+)$/m);
      if (hostMatch) config.host = hostMatch[1].trim();

      return config;
    } catch {
      return {};
    }
  }

  // -------------------------------------------------------------------------
  // Bun binary resolution
  // -------------------------------------------------------------------------

  /**
   * Resolves the full path to the `bun` binary.
   */
  private getBunPath(): string {
    try {
      const bunPath = execSync("which bun", { encoding: "utf-8" }).trim();
      return bunPath;
    } catch {
      // Fallback to common locations
      const homeDir = homedir();
      const candidates = [
        join(homeDir, ".bun", "bin", "bun"),
        "/usr/local/bin/bun",
        "/opt/homebrew/bin/bun",
      ];
      for (const p of candidates) {
        if (existsSync(p)) return p;
      }
      return "bun"; // hope it's on PATH
    }
  }

  /**
   * Builds the command-line arguments for the proxy.
   */
  private buildArgs(): string[] {
    const args = ["run", join(this.config.projectDir, "src", "index.ts")];
    args.push("--port", String(this.config.port));
    args.push("--host", this.config.host);
    if (this.config.model) {
      args.push("--model", this.config.model);
    }
    if (this.config.verbose) {
      args.push("--verbose");
    }
    return args;
  }

  // -------------------------------------------------------------------------
  // macOS – launchd
  // -------------------------------------------------------------------------

  private get plistPath(): string {
    return join(homedir(), "Library", "LaunchAgents", `${SERVICE_LABEL}.plist`);
  }

  private get logDir(): string {
    return join(homedir(), "Library", "Logs", SERVICE_NAME);
  }

  private installMacOS(): void {
    const bunPath = this.getBunPath();
    const args = this.buildArgs();

    // Ensure log directory exists
    if (!existsSync(this.logDir)) {
      mkdirSync(this.logDir, { recursive: true });
    }

    const plist = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${SERVICE_LABEL}</string>

    <key>ProgramArguments</key>
    <array>
        <string>${bunPath}</string>
${args.map((a) => `        <string>${a}</string>`).join("\n")}
    </array>

    <key>WorkingDirectory</key>
    <string>${this.config.projectDir}</string>

    <key>EnvironmentVariables</key>
    <dict>
        <key>GEMINI_API_KEY</key>
        <string>${this.config.apiKey}</string>
        <key>PATH</key>
        <string>/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin:${join(homedir(), ".bun", "bin")}</string>
    </dict>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <dict>
        <key>SuccessfulExit</key>
        <false/>
    </dict>

    <key>StandardOutPath</key>
    <string>${join(this.logDir, "stdout.log")}</string>

    <key>StandardErrorPath</key>
    <string>${join(this.logDir, "stderr.log")}</string>

    <key>ThrottleInterval</key>
    <integer>10</integer>
</dict>
</plist>`;

    writeFileSync(this.plistPath, plist, "utf-8");

    // Load the service
    try {
      execSync(`launchctl unload "${this.plistPath}" 2>/dev/null`, {
        stdio: "ignore",
      });
    } catch {
      // Ignore if not loaded
    }
    execSync(`launchctl load -w "${this.plistPath}"`);

    console.log(`
${C.green}${C.bold}✓ Service installed successfully!${C.reset}

  ${C.bold}Platform:${C.reset}  macOS (launchd)
  ${C.bold}Plist:${C.reset}     ${this.plistPath}
  ${C.bold}Logs:${C.reset}      ${this.logDir}/

  The proxy will start automatically on login.
  It's already running now on ${C.cyan}http://${this.config.host}:${this.config.port}${C.reset}

  ${C.dim}To check status:${C.reset}  gemini-claude-code service status
  ${C.dim}To uninstall:${C.reset}    gemini-claude-code service uninstall
  ${C.dim}View logs:${C.reset}      tail -f ${this.logDir}/stdout.log
`);
  }

  private uninstallMacOS(): void {
    if (existsSync(this.plistPath)) {
      try {
        execSync(`launchctl unload "${this.plistPath}"`, { stdio: "ignore" });
      } catch {
        // Ignore errors
      }
      unlinkSync(this.plistPath);
      console.log(
        `\n${C.green}${C.bold}✓ Service uninstalled.${C.reset} Auto-start removed.\n`
      );
    } else {
      console.log(
        `\n${C.yellow}Service not installed.${C.reset} Nothing to remove.\n`
      );
    }
  }

  private statusMacOS(): void {
    if (!existsSync(this.plistPath)) {
      console.log(
        `\n  ${C.yellow}●${C.reset} Service ${C.bold}not installed${C.reset}\n`
      );
      return;
    }

    try {
      const output = execSync(`launchctl list | grep ${SERVICE_LABEL}`, {
        encoding: "utf-8",
      });
      const parts = output.trim().split(/\s+/);
      const pid = parts[0];
      const exitCode = parts[1];

      if (pid && pid !== "-") {
        const saved = this.getSavedConfig();
        const port = saved.port ?? this.config.port;
        const host = saved.host ?? this.config.host;
        console.log(
          `\n  ${C.green}●${C.reset} Service ${C.bold}running${C.reset} (PID: ${pid})`
        );
        console.log(
          `  ${C.dim}Listening on${C.reset} http://${host}:${port}\n`
        );
      } else {
        console.log(
          `\n  ${C.red}●${C.reset} Service ${C.bold}stopped${C.reset} (last exit code: ${exitCode})`
        );
        console.log(
          `  ${C.dim}Check logs:${C.reset} tail -f ${this.logDir}/stderr.log\n`
        );
      }
    } catch {
      console.log(
        `\n  ${C.red}●${C.reset} Service ${C.bold}not running${C.reset}\n`
      );
    }
  }

  // -------------------------------------------------------------------------
  // Linux – systemd user service
  // -------------------------------------------------------------------------

  private get systemdDir(): string {
    return join(homedir(), ".config", "systemd", "user");
  }

  private get servicePath(): string {
    return join(this.systemdDir, `${SERVICE_NAME}.service`);
  }

  private installLinux(): void {
    const bunPath = this.getBunPath();
    const args = this.buildArgs();
    const execStart = `${bunPath} ${args.join(" ")}`;

    if (!existsSync(this.systemdDir)) {
      mkdirSync(this.systemdDir, { recursive: true });
    }

    const unit = `[Unit]
Description=${SERVICE_DESCRIPTION}
After=network.target

[Service]
Type=simple
ExecStart=${execStart}
WorkingDirectory=${this.config.projectDir}
Environment="GEMINI_API_KEY=${this.config.apiKey}"
Environment="PATH=/usr/local/bin:${join(homedir(), ".bun", "bin")}:/usr/bin:/bin"
Restart=on-failure
RestartSec=10

[Install]
WantedBy=default.target
`;

    writeFileSync(this.servicePath, unit, "utf-8");

    // Reload and enable
    execSync("systemctl --user daemon-reload");
    execSync(`systemctl --user enable ${SERVICE_NAME}`);
    execSync(`systemctl --user start ${SERVICE_NAME}`);

    console.log(`
${C.green}${C.bold}✓ Service installed successfully!${C.reset}

  ${C.bold}Platform:${C.reset}  Linux (systemd)
  ${C.bold}Unit:${C.reset}      ${this.servicePath}

  The proxy will start automatically on login.
  It's already running now on ${C.cyan}http://${this.config.host}:${this.config.port}${C.reset}

  ${C.dim}To check status:${C.reset}   systemctl --user status ${SERVICE_NAME}
  ${C.dim}To view logs:${C.reset}      journalctl --user -u ${SERVICE_NAME} -f
  ${C.dim}To uninstall:${C.reset}      gemini-claude-code service uninstall
`);
  }

  private uninstallLinux(): void {
    if (existsSync(this.servicePath)) {
      try {
        execSync(`systemctl --user stop ${SERVICE_NAME}`, { stdio: "ignore" });
        execSync(`systemctl --user disable ${SERVICE_NAME}`, {
          stdio: "ignore",
        });
      } catch {
        // Ignore errors
      }
      unlinkSync(this.servicePath);
      execSync("systemctl --user daemon-reload");
      console.log(
        `\n${C.green}${C.bold}✓ Service uninstalled.${C.reset} Auto-start removed.\n`
      );
    } else {
      console.log(
        `\n${C.yellow}Service not installed.${C.reset} Nothing to remove.\n`
      );
    }
  }

  private statusLinux(): void {
    if (!existsSync(this.servicePath)) {
      console.log(
        `\n  ${C.yellow}●${C.reset} Service ${C.bold}not installed${C.reset}\n`
      );
      return;
    }

    try {
      const output = execSync(
        `systemctl --user is-active ${SERVICE_NAME}`,
        { encoding: "utf-8" }
      ).trim();

      if (output === "active") {
        const saved = this.getSavedConfig();
        const port = saved.port ?? this.config.port;
        const host = saved.host ?? this.config.host;
        console.log(
          `\n  ${C.green}●${C.reset} Service ${C.bold}running${C.reset}`
        );
        console.log(
          `  ${C.dim}Listening on${C.reset} http://${host}:${port}\n`
        );
      } else {
        console.log(
          `\n  ${C.red}●${C.reset} Service ${C.bold}${output}${C.reset}\n`
        );
      }
    } catch {
      console.log(
        `\n  ${C.red}●${C.reset} Service ${C.bold}not running${C.reset}\n`
      );
    }
  }

  // -------------------------------------------------------------------------
  // Windows – Startup folder VBS wrapper
  // -------------------------------------------------------------------------

  private get startupDir(): string {
    return join(
      process.env.APPDATA ?? join(homedir(), "AppData", "Roaming"),
      "Microsoft",
      "Windows",
      "Start Menu",
      "Programs",
      "Startup"
    );
  }

  private get vbsPath(): string {
    return join(this.startupDir, `${SERVICE_NAME}.vbs`);
  }

  private get batPath(): string {
    return join(this.config.projectDir, `${SERVICE_NAME}-start.bat`);
  }

  private installWindows(): void {
    const bunPath = this.getBunPath().replace(/\//g, "\\");
    const args = this.buildArgs();
    const projectDir = this.config.projectDir.replace(/\//g, "\\");

    // Create a .bat file that sets env vars and starts the server
    const bat = `@echo off
set GEMINI_API_KEY=${this.config.apiKey}
cd /d "${projectDir}"
"${bunPath}" ${args.join(" ")}
`;

    writeFileSync(this.batPath, bat, "utf-8");

    // Create a VBS wrapper to run the bat silently (no cmd window)
    const vbs = `Set WshShell = CreateObject("WScript.Shell")
WshShell.Run """${this.batPath.replace(/\//g, "\\")}""", 0, False
Set WshShell = Nothing
`;

    writeFileSync(this.vbsPath, vbs, "utf-8");

    console.log(`
${C.green}${C.bold}✓ Service installed successfully!${C.reset}

  ${C.bold}Platform:${C.reset}  Windows (Startup folder)
  ${C.bold}Script:${C.reset}    ${this.vbsPath}
  ${C.bold}Runner:${C.reset}    ${this.batPath}

  The proxy will start automatically on login.
  ${C.dim}Run the .bat manually to start now, or restart your PC.${C.reset}

  ${C.dim}To uninstall:${C.reset}  gemini-claude-code service uninstall
`);
  }

  private uninstallWindows(): void {
    let removed = false;

    if (existsSync(this.vbsPath)) {
      unlinkSync(this.vbsPath);
      removed = true;
    }
    if (existsSync(this.batPath)) {
      unlinkSync(this.batPath);
      removed = true;
    }

    if (removed) {
      console.log(
        `\n${C.green}${C.bold}✓ Service uninstalled.${C.reset} Auto-start removed.\n`
      );
    } else {
      console.log(
        `\n${C.yellow}Service not installed.${C.reset} Nothing to remove.\n`
      );
    }
  }

  private statusWindows(): void {
    if (!existsSync(this.vbsPath)) {
      console.log(
        `\n  ${C.yellow}●${C.reset} Service ${C.bold}not installed${C.reset}\n`
      );
      return;
    }
    console.log(
      `\n  ${C.green}●${C.reset} Service ${C.bold}installed${C.reset} (starts on login)`
    );
    console.log(`  ${C.dim}Script:${C.reset} ${this.vbsPath}\n`);
  }
}
